package tests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/gojuno/minimock/v3/tests.contextAccepter -o context_accepter_mock.go -n ContextAccepterMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContextAccepterMock implements contextAccepter
type ContextAccepterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptContext          func(ctx context.Context)
	inspectFuncAcceptContext   func(ctx context.Context)
	afterAcceptContextCounter  uint64
	beforeAcceptContextCounter uint64
	AcceptContextMock          mContextAccepterMockAcceptContext

	funcAcceptContextWithOtherArgs          func(ctx context.Context, i1 int) (i2 int, err error)
	inspectFuncAcceptContextWithOtherArgs   func(ctx context.Context, i1 int)
	afterAcceptContextWithOtherArgsCounter  uint64
	beforeAcceptContextWithOtherArgsCounter uint64
	AcceptContextWithOtherArgsMock          mContextAccepterMockAcceptContextWithOtherArgs
}

// NewContextAccepterMock returns a mock for contextAccepter
func NewContextAccepterMock(t minimock.Tester) *ContextAccepterMock {
	m := &ContextAccepterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptContextMock = mContextAccepterMockAcceptContext{mock: m}
	m.AcceptContextMock.callArgs = []*ContextAccepterMockAcceptContextParams{}

	m.AcceptContextWithOtherArgsMock = mContextAccepterMockAcceptContextWithOtherArgs{mock: m}
	m.AcceptContextWithOtherArgsMock.callArgs = []*ContextAccepterMockAcceptContextWithOtherArgsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mContextAccepterMockAcceptContext struct {
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextExpectation
	expectations       []*ContextAccepterMockAcceptContextExpectation

	callArgs []*ContextAccepterMockAcceptContextParams
	mutex    sync.RWMutex
}

// ContextAccepterMockAcceptContextExpectation specifies expectation struct of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextExpectation struct {
	mock   *ContextAccepterMock
	params *ContextAccepterMockAcceptContextParams

	Counter uint64
}

// ContextAccepterMockAcceptContextParams contains parameters of the contextAccepter.AcceptContext
type ContextAccepterMockAcceptContextParams struct {
	ctx context.Context
}

// Expect sets up expected params for contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Expect(ctx context.Context) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{}
	}

	mmAcceptContext.defaultExpectation.params = &ContextAccepterMockAcceptContextParams{ctx}
	for _, e := range mmAcceptContext.expectations {
		if minimock.Equal(e.params, mmAcceptContext.defaultExpectation.params) {
			mmAcceptContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContext.defaultExpectation.params)
		}
	}

	return mmAcceptContext
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Inspect(f func(ctx context.Context)) *mContextAccepterMockAcceptContext {
	if mmAcceptContext.mock.inspectFuncAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContext")
	}

	mmAcceptContext.mock.inspectFuncAcceptContext = f

	return mmAcceptContext
}

// Return sets up results that will be returned by contextAccepter.AcceptContext
func (mmAcceptContext *mContextAccepterMockAcceptContext) Return() *ContextAccepterMock {
	if mmAcceptContext.mock.funcAcceptContext != nil {
		mmAcceptContext.mock.t.Fatalf("ContextAccepterMock.AcceptContext mock is already set by Set")
	}

	if mmAcceptContext.defaultExpectation == nil {
		mmAcceptContext.defaultExpectation = &ContextAccepterMockAcceptContextExpectation{mock: mmAcceptContext.mock}
	}

	return mmAcceptContext.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContext method
func (mmAcceptContext *mContextAccepterMockAcceptContext) Set(f func(ctx context.Context)) *ContextAccepterMock {
	if mmAcceptContext.defaultExpectation != nil {
		mmAcceptContext.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContext method")
	}

	if len(mmAcceptContext.expectations) > 0 {
		mmAcceptContext.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContext method")
	}

	mmAcceptContext.mock.funcAcceptContext = f
	return mmAcceptContext.mock
}

// AcceptContext implements contextAccepter
func (mmAcceptContext *ContextAccepterMock) AcceptContext(ctx context.Context) {
	mm_atomic.AddUint64(&mmAcceptContext.beforeAcceptContextCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContext.afterAcceptContextCounter, 1)

	if mmAcceptContext.inspectFuncAcceptContext != nil {
		mmAcceptContext.inspectFuncAcceptContext(ctx)
	}

	mm_params := ContextAccepterMockAcceptContextParams{ctx}

	// Record call args
	mmAcceptContext.AcceptContextMock.mutex.Lock()
	mmAcceptContext.AcceptContextMock.callArgs = append(mmAcceptContext.AcceptContextMock.callArgs, &mm_params)
	mmAcceptContext.AcceptContextMock.mutex.Unlock()

	for _, e := range mmAcceptContext.AcceptContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAcceptContext.AcceptContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContext.AcceptContextMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContext.AcceptContextMock.defaultExpectation.params
		mm_got := ContextAccepterMockAcceptContextParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContext.t.Errorf("ContextAccepterMock.AcceptContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAcceptContext.funcAcceptContext != nil {
		mmAcceptContext.funcAcceptContext(ctx)
		return
	}
	mmAcceptContext.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContext. %v", ctx)

}

// AcceptContextAfterCounter returns a count of finished ContextAccepterMock.AcceptContext invocations
func (mmAcceptContext *ContextAccepterMock) AcceptContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContext.afterAcceptContextCounter)
}

// AcceptContextBeforeCounter returns a count of ContextAccepterMock.AcceptContext invocations
func (mmAcceptContext *ContextAccepterMock) AcceptContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContext.beforeAcceptContextCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContext *mContextAccepterMockAcceptContext) Calls() []*ContextAccepterMockAcceptContextParams {
	mmAcceptContext.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextParams, len(mmAcceptContext.callArgs))
	copy(argCopy, mmAcceptContext.callArgs)

	mmAcceptContext.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextDone returns true if the count of the AcceptContext invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextDone() bool {
	for _, e := range m.AcceptContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcceptContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContext != nil && mm_atomic.LoadUint64(&m.afterAcceptContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcceptContextInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextInspect() {
	for _, e := range m.AcceptContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcceptContextCounter) < 1 {
		if m.AcceptContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContextAccepterMock.AcceptContext")
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContext with params: %#v", *m.AcceptContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContext != nil && mm_atomic.LoadUint64(&m.afterAcceptContextCounter) < 1 {
		m.t.Error("Expected call to ContextAccepterMock.AcceptContext")
	}
}

type mContextAccepterMockAcceptContextWithOtherArgs struct {
	mock               *ContextAccepterMock
	defaultExpectation *ContextAccepterMockAcceptContextWithOtherArgsExpectation
	expectations       []*ContextAccepterMockAcceptContextWithOtherArgsExpectation

	callArgs []*ContextAccepterMockAcceptContextWithOtherArgsParams
	mutex    sync.RWMutex
}

// ContextAccepterMockAcceptContextWithOtherArgsExpectation specifies expectation struct of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsExpectation struct {
	mock    *ContextAccepterMock
	params  *ContextAccepterMockAcceptContextWithOtherArgsParams
	results *ContextAccepterMockAcceptContextWithOtherArgsResults
	Counter uint64
}

// ContextAccepterMockAcceptContextWithOtherArgsParams contains parameters of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsParams struct {
	ctx context.Context
	i1  int
}

// ContextAccepterMockAcceptContextWithOtherArgsResults contains results of the contextAccepter.AcceptContextWithOtherArgs
type ContextAccepterMockAcceptContextWithOtherArgsResults struct {
	i2  int
	err error
}

// Expect sets up expected params for contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Expect(ctx context.Context, i1 int) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{}
	}

	mmAcceptContextWithOtherArgs.defaultExpectation.params = &ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}
	for _, e := range mmAcceptContextWithOtherArgs.expectations {
		if minimock.Equal(e.params, mmAcceptContextWithOtherArgs.defaultExpectation.params) {
			mmAcceptContextWithOtherArgs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptContextWithOtherArgs.defaultExpectation.params)
		}
	}

	return mmAcceptContextWithOtherArgs
}

// Inspect accepts an inspector function that has same arguments as the contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Inspect(f func(ctx context.Context, i1 int)) *mContextAccepterMockAcceptContextWithOtherArgs {
	if mmAcceptContextWithOtherArgs.mock.inspectFuncAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Inspect function is already set for ContextAccepterMock.AcceptContextWithOtherArgs")
	}

	mmAcceptContextWithOtherArgs.mock.inspectFuncAcceptContextWithOtherArgs = f

	return mmAcceptContextWithOtherArgs
}

// Return sets up results that will be returned by contextAccepter.AcceptContextWithOtherArgs
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Return(i2 int, err error) *ContextAccepterMock {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	if mmAcceptContextWithOtherArgs.defaultExpectation == nil {
		mmAcceptContextWithOtherArgs.defaultExpectation = &ContextAccepterMockAcceptContextWithOtherArgsExpectation{mock: mmAcceptContextWithOtherArgs.mock}
	}
	mmAcceptContextWithOtherArgs.defaultExpectation.results = &ContextAccepterMockAcceptContextWithOtherArgsResults{i2, err}
	return mmAcceptContextWithOtherArgs.mock
}

// Set uses given function f to mock the contextAccepter.AcceptContextWithOtherArgs method
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Set(f func(ctx context.Context, i1 int) (i2 int, err error)) *ContextAccepterMock {
	if mmAcceptContextWithOtherArgs.defaultExpectation != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Default expectation is already set for the contextAccepter.AcceptContextWithOtherArgs method")
	}

	if len(mmAcceptContextWithOtherArgs.expectations) > 0 {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("Some expectations are already set for the contextAccepter.AcceptContextWithOtherArgs method")
	}

	mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs = f
	return mmAcceptContextWithOtherArgs.mock
}

// When sets expectation for the contextAccepter.AcceptContextWithOtherArgs which will trigger the result defined by the following
// Then helper
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) When(ctx context.Context, i1 int) *ContextAccepterMockAcceptContextWithOtherArgsExpectation {
	if mmAcceptContextWithOtherArgs.mock.funcAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.mock.t.Fatalf("ContextAccepterMock.AcceptContextWithOtherArgs mock is already set by Set")
	}

	expectation := &ContextAccepterMockAcceptContextWithOtherArgsExpectation{
		mock:   mmAcceptContextWithOtherArgs.mock,
		params: &ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1},
	}
	mmAcceptContextWithOtherArgs.expectations = append(mmAcceptContextWithOtherArgs.expectations, expectation)
	return expectation
}

// Then sets up contextAccepter.AcceptContextWithOtherArgs return parameters for the expectation previously defined by the When method
func (e *ContextAccepterMockAcceptContextWithOtherArgsExpectation) Then(i2 int, err error) *ContextAccepterMock {
	e.results = &ContextAccepterMockAcceptContextWithOtherArgsResults{i2, err}
	return e.mock
}

// AcceptContextWithOtherArgs implements contextAccepter
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgs(ctx context.Context, i1 int) (i2 int, err error) {
	mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.beforeAcceptContextWithOtherArgsCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.afterAcceptContextWithOtherArgsCounter, 1)

	if mmAcceptContextWithOtherArgs.inspectFuncAcceptContextWithOtherArgs != nil {
		mmAcceptContextWithOtherArgs.inspectFuncAcceptContextWithOtherArgs(ctx, i1)
	}

	mm_params := ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}

	// Record call args
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.mutex.Lock()
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.callArgs = append(mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.callArgs, &mm_params)
	mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.mutex.Unlock()

	for _, e := range mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i2, e.results.err
		}
	}

	if mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.params
		mm_got := ContextAccepterMockAcceptContextWithOtherArgsParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptContextWithOtherArgs.t.Errorf("ContextAccepterMock.AcceptContextWithOtherArgs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptContextWithOtherArgs.AcceptContextWithOtherArgsMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptContextWithOtherArgs.t.Fatal("No results are set for the ContextAccepterMock.AcceptContextWithOtherArgs")
		}
		return (*mm_results).i2, (*mm_results).err
	}
	if mmAcceptContextWithOtherArgs.funcAcceptContextWithOtherArgs != nil {
		return mmAcceptContextWithOtherArgs.funcAcceptContextWithOtherArgs(ctx, i1)
	}
	mmAcceptContextWithOtherArgs.t.Fatalf("Unexpected call to ContextAccepterMock.AcceptContextWithOtherArgs. %v %v", ctx, i1)
	return
}

// AcceptContextWithOtherArgsAfterCounter returns a count of finished ContextAccepterMock.AcceptContextWithOtherArgs invocations
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.afterAcceptContextWithOtherArgsCounter)
}

// AcceptContextWithOtherArgsBeforeCounter returns a count of ContextAccepterMock.AcceptContextWithOtherArgs invocations
func (mmAcceptContextWithOtherArgs *ContextAccepterMock) AcceptContextWithOtherArgsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptContextWithOtherArgs.beforeAcceptContextWithOtherArgsCounter)
}

// Calls returns a list of arguments used in each call to ContextAccepterMock.AcceptContextWithOtherArgs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptContextWithOtherArgs *mContextAccepterMockAcceptContextWithOtherArgs) Calls() []*ContextAccepterMockAcceptContextWithOtherArgsParams {
	mmAcceptContextWithOtherArgs.mutex.RLock()

	argCopy := make([]*ContextAccepterMockAcceptContextWithOtherArgsParams, len(mmAcceptContextWithOtherArgs.callArgs))
	copy(argCopy, mmAcceptContextWithOtherArgs.callArgs)

	mmAcceptContextWithOtherArgs.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptContextWithOtherArgsDone returns true if the count of the AcceptContextWithOtherArgs invocations corresponds
// the number of defined expectations
func (m *ContextAccepterMock) MinimockAcceptContextWithOtherArgsDone() bool {
	for _, e := range m.AcceptContextWithOtherArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextWithOtherArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcceptContextWithOtherArgsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContextWithOtherArgs != nil && mm_atomic.LoadUint64(&m.afterAcceptContextWithOtherArgsCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcceptContextWithOtherArgsInspect logs each unmet expectation
func (m *ContextAccepterMock) MinimockAcceptContextWithOtherArgsInspect() {
	for _, e := range m.AcceptContextWithOtherArgsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptContextWithOtherArgsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcceptContextWithOtherArgsCounter) < 1 {
		if m.AcceptContextWithOtherArgsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs")
		} else {
			m.t.Errorf("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs with params: %#v", *m.AcceptContextWithOtherArgsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptContextWithOtherArgs != nil && mm_atomic.LoadUint64(&m.afterAcceptContextWithOtherArgsCounter) < 1 {
		m.t.Error("Expected call to ContextAccepterMock.AcceptContextWithOtherArgs")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContextAccepterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptContextInspect()

			m.MinimockAcceptContextWithOtherArgsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContextAccepterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContextAccepterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptContextDone() &&
		m.MinimockAcceptContextWithOtherArgsDone()
}
